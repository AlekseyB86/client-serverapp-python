# GB. Клиент-серверные приложения на Python.

# Урок 1. Концепция хранения информации.

# Урок 2. Файловое хранение данных.

# Урок 3. Основы сетевого программирования.

# Урок 4. Основы тестирования.

# Урок 5. Логирование.

# Урок 6. Декораторы и продолжение работы с сетью.

    1. Продолжая задачу логирования, реализовать декоратор @log, фиксирующий обращение к декорируемой функции.
        Он сохраняет ее имя и аргументы.
    2. * В декораторе @log реализовать фиксацию функции, из которой была вызвана декорированная.
        Если имеется такой код:
            @log
            def func_z():
             pass
            
            def main():
             func_z()
        ...в логе должна быть отражена информация:"<дата-время> Функция func_z() вызвана из функции main"

# Урок 7. Модуль select, слоты.

    1. Реализовать обработку нескольких клиентов на сервере, используя функцию select.
        Клиенты должны общаться в «общем чате»: каждое сообщение участника отправляется всем, подключенным к серверу.
    2. Реализовать функции отправки/приема данных на стороне клиента.
        Чтобы упростить разработку на данном этапе, пусть клиентское приложение будет либо только принимать,
        либо только отправлять сообщения в общий чат. Эти функции надо реализовать в рамках отдельных скриптов.

# Урок 8. Потоки

   1. На клиентской стороне реализовать прием и отправку сообщений с помощью потоков в P2P-формате (обмен сообщениями 
       между двумя пользователями).
    
   Итогом выполнения домашних заданий первой части продвинутого курса Python стал консольный мессенджер.
   Усовершенствуем его во второй части: реализуем взаимосвязь мессенджера с базами данных и создадим для него
   графический пользовательский интерфейс.